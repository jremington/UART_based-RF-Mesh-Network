//myNode=2, partner=1, MAXNODES 4
/* Wireless mesh for Arduino and APC220 modules from:

  http://duino4projects.com/simple-arduino-wireless-mesh/
  http://www.instructables.com/id/Introducing-LoRa-/

  NO STRINGS version 1/19/2018 by SJR. All String objects and manipulations removed and replaced by C strings
  sjames.remington at gmail.com  This version compatible with above protocol descriptions if MAXNODES=16

  Some of the following comments from the original code need updating (SJR)

  Each node samples two analog voltages. Each node can output two analog voltages.
  Nodes all work on the same RF frequency. They are synchronised so each transmits in a particular time slot.
  Time signals are generated by the lowest numbered node.
  Tested with up to 16 nodes in the mesh.

  Each time slot is 4096ms, and so it takes around 4 to 80 seconds to send data through the mesh.
  Each node also transmits its local time (sync within a few ms).
  Each node samples its analog inputs, and puts a time stamp on these values.
  Each node stores all the values of all other nodes, so 16 nodes, 2 values per node is 32 values.
  When a node is ready to transmit, it sends all 32 values, with associated time stamps.
  When receiving, if a value has a newer time stamp, then replace it.
  This means that newer values propagate through the mesh.

  Nodes can be paired together, so adjusting a potentiometer on one node will change the voltage on another node (with 4 to 80s delay)
  Each node can either be a repeater, or input values, or output values, or all of these at once.
  The mesh can tolerate repeater nodes being removed. Ideally there are several paths data can take.
  APC220 modules have open air ranges of up to 1000m. Trees and metal (eg a shed) can greatly decrease this though, to as low as 50m.
  The mesh allows signals to get around buildings and barriers.

  The 4096ms time slot was calculated as the time needed to send all node data at 9600 baud, using human readable hex (ascii 32 to 126)
  and allowing for delays of about 150ms between each packet. This means there are two bytes per value (eg F1) and theoretically
  it would be possible to send this as a single byte. However, then ascii 13 can't be used as an end of line marker, and then packets
  have to be constructed with start and finish bytes and they get more complex to code.

  Current consumption of a node is about 25mA for the Arduino, 30mA for an APC220 radio module.
*/


/*
  GNU General Public License, version 3 (GPL-3.0)
*/

#include <AltSoftSerial.h>

// AltSoftSerial always uses these pins:
//
// Board          Transmit  Receive   PWM Unusable
// -----          --------  -------   ------------
// Teensy 3.0 & 3.1  21        20         22
// Teensy 2.0         9        10       (none)
// Teensy++ 2.0      25         4       26, 27
// Arduino Uno        9         8         10
// Arduino Leonardo   5        13       (none)
// Arduino Mega      46        48       44, 45
// Wiring-S           5         6          4
// Sanguino          13        14         12

//NOW use standard serial port for local output, AltSoftSerial for radio (SJR)

AltSoftSerial altSerial;

//MAXNODES must be a power of 2, 256 max possible with the current message format
#define MAXNODES 4

byte myNode = 2; // my node number
byte partnerNode = 1; // output the values from this partner node

//estimated propagation delay in milliseconds for time sync messages.
#define PropDelay 20

// global variables
unsigned long timeCentral = 0; // time from lowest numbered node
unsigned long timeOffset  = 0; // offset from my local millis counter 
unsigned long timeCheck = 0; //timeout for low node number check (in case of node dropouts, now 10 min.)
#define REFNODETIMEOUT 600000UL

char radioString[32] = {0}; //30 character input buffer
char stemp[40]; //temporary string space for sprintf

int nodeValuesA0[MAXNODES] = {0}; // A0 values, 16 nodes in a mesh
int nodeValuesA1[MAXNODES] = {0}; // A1 values
unsigned long nodeTimestamps[MAXNODES] = {0}; // timestamps for each value
int lowestNode = 255; // 0 to 15, 255 is false, 0-15 is node last got a time sync signal from

void setup()
{
  Serial.begin(38400); // debug port and serial data out

  pinMode(13, OUTPUT);  // led
  pinMode(3, OUTPUT); // analog output 0
  pinMode(5, OUTPUT); // analog output 1
  altSerial.begin(9600);  //check if limited by radio

  Serial.print("Mesh (");
  Serial.print(MAXNODES);
  Serial.print(") node= ");
  Serial.print(myNode);
  Serial.print(" partner= "); // debug output
  Serial.println(partnerNode);
}

void loop()
{
  rxRadio();  //check for input from radio
  NodeTimeSlot(); //check time, is it our slot?
}

// radio routines

void rxRadio()
{
  char c;
  while (altSerial.available())
  {
    c = altSerial.read(); // fetch the char
    processRadioString(c); // is it a command?
  }
}

// parse input command
void processRadioString(char c)
{
  int inptr = strlen(radioString);
  if (inptr > 30) // string too long
  {
    radioString[0] = 0; //end it
    Serial.println("*Input too long");
  }

  if ((c > 31) && (c < 127)) // only store printable characters, use 13 as end of line marker
  {
    radioString[inptr++] = c; // add to the string
    radioString[inptr] = 0; //end it
    Serial.print(c); // DEBUG print the character so can see data coming in
  }
  if (c == 13) // process the command or carriage return received
  {
    Serial.println("<"); //DEBUG incoming!
    digitalWrite(13, HIGH);
    if (strncmp(radioString, "Time=", 5) == 0) processTimeSignal(); // parse time sync command
    if (strncmp(radioString, "Data=", 5) == 0) processDataMessage(); // node,samples,timestamp
    //clear radioString
    radioString[0] = 0;
    digitalWrite(13, LOW);
  }
}

void processTimeSignal() // parse message "Time = 03 00000000" where 03 is the originating node
{
  unsigned long centraltime;
  unsigned long mytime;
  int timeFrom;
  int n = sscanf(radioString, "Time=%2x %8lx", &timeFrom, &centraltime);
  if (n != 2) {
    Serial.print("*Time msg error, ");
    Serial.print(n);
    Serial.print(" vals converted >");
    Serial.println(radioString);
    return;
  }
  if (millis() - timeCheck > REFNODETIMEOUT) //long time no see?
  {
    timeCheck = millis();
    lowestNode = 255; //reset timekeeping node
  }

  if (timeFrom <= lowestNode && timeFrom < myNode) // current time slot is less or equal than the last time node number
  {                                                // do not update clock offset if time node is >= myNode
    mytime = millis();  //time stamp for this received time sync
    timeOffset = centraltime + PropDelay - mytime;  //PropDelay needs to be measured by other means
    sprintf(stemp, "CT %08lx<%02x: offset %08lx", centraltime, timeFrom, timeOffset); //31 chars
    Serial.println(stemp);
    displayTime();
    lowestNode = timeFrom; // update with the new current lowest node number
  }
  else displayTime();
}

void refreshTime()
{
  timeCentral = millis() + timeOffset;
}

void displayTime()
{
  refreshTime();
  Serial.print("Node time ");
  Serial.println(timeCentral / 1000.); // print time in seconds
}

void transmitTime() // send my local time, will converge on the lowest node number's time
{
  refreshTime();
  sprintf(stemp, "Time=%02X %08lX", myNode, timeCentral);
  altSerial.println(stemp); // transmit via radio
  Serial.println(stemp); // debug
}

// Data=0302AAAABBBBCCCCCCCCcrlf where 03 is from, 02 is node (hex), AAAA, BBBB 2 bytes hex data, C. is the time stamp
void processDataMessage()
{
  unsigned int node;
  unsigned int valueA0;
  unsigned int valueA1;
  unsigned int from;
  unsigned long age;
  unsigned long timestamp;
  unsigned long previousage;

  int n = sscanf(radioString, "Data=%2X%2X%4X%4X%8lX", &from, &node, &valueA0, &valueA1, &timestamp);
  if (n != 5) {
    Serial.print("*Data msg error, ");
    Serial.print(n);
    Serial.print(" vals converted >");
    Serial.println(radioString);
    return;
  }

  age = (unsigned long) (timeCentral - timestamp);
  previousage = (unsigned long) (timeCentral - nodeTimestamps[node]);
  if (age < previousage) // more recent data so update
  {
    nodeTimestamps[node] = timestamp; // update the time stamp
    nodeValuesA0[node] = valueA0; // update the values
    nodeValuesA1[node] = valueA1; // A1 as well
    //    sprintf(stemp, "update: %02X %02X %04X %04X %08lX", from, node, valueA0, valueA1, timestamp); //32 chars
    //    Serial.println(stemp);
    Serial.print(node);
    Serial.println(" updated");
    analogOutput(); // update the analog outputs, may or may not have been updated recently
  }
}

void createDataMessage() // read A0 and A1, create data string
{
  int i;
  updateMyValues(); // update my analog input
  //  Serial.print("Node ");
  Serial.print(myNode);
  Serial.print("> ");
  Serial.print(nodeValuesA0[myNode], HEX);
  Serial.print(", ");
  Serial.println(nodeValuesA1[myNode], HEX);

  // send latest values for all nodes, as stored on this node

  for (i = 0; i < MAXNODES; i++) {
    sprintf(stemp, "Data=%02X%02X%04X%04X%08lX", myNode, i, nodeValuesA0[i], nodeValuesA1[i], nodeTimestamps[i]);  // 25 chars
    altSerial.println(stemp); // transmit via radio
    //    Serial.println(stemp); // debug
    delay(100); // give receiving node time to process, errors on 75, ok on 100
  }
}

void updateMyValues()
{
  refreshTime(); // get timeCentral
  int sensorValue = analogRead(A0);
  sensorValue = analogRead(A0); //twice to avoid glitches
  nodeValuesA0[myNode] = sensorValue;
  sensorValue = analogRead(A1);
  sensorValue = analogRead(A1); //twice to avoid glitches
  nodeValuesA1[myNode] = sensorValue;
  nodeTimestamps[myNode] = timeCentral; // updated at this time
}

// time slots are 4096 milliseconds - must be power of two
void NodeTimeSlot()
{
  unsigned long t;
  unsigned long remainder;
  int timeSlot = 0;

  refreshTime(); // update timeCentral
  
// mask out low bits of time
  t = timeCentral & 0xFFFFF000;
  remainder = timeCentral - t;

  if (remainder < 100) // beginning of a 4096ms time slot
  {
    digitalWrite(13, HIGH);
    timeSlot = getTimeSlot();
    sprintf(stemp, "Slot %02d", timeSlot);
    Serial.println(stemp);

    //  printHeapStack(); // heap should always be less than stack

//    delay(110);  //why this delay? (SJR)
    digitalWrite(13, LOW);
    if (timeSlot == myNode) // transmit if in my time slot
    {
      digitalWrite(13, HIGH); // led on while tx data message
      transmitTime();
      createDataMessage(); // send out all my local data via radio
      //      outputRS232(); // send out all the node values via RS232 port (eg to a PC)
      digitalWrite(13, LOW); // led off
    }
  }
}

 int getTimeSlot() // find out which time slot we are in
{
  unsigned long x;
  refreshTime();
  x = timeCentral >> 12; // divide by 4096
  //  x = x & 0x0000000F; // mask so one of 16
  x = x & (MAXNODES - 1);
  return (int) x;
}

/* This function places the current value of the heap and stack pointers in the
  variables. You can call it from any place in your code and save the data for
  outputting or displaying later. This allows you to check at different parts of
  your program flow.
  The stack pointer starts at the top of RAM and grows downwards. The heap pointer
  starts just above the static variables etc. and grows upwards. SP should always
  be larger than HP or you'll be in big trouble! The smaller the gap, the more
  careful you need to be. Julian Gall 6-Feb-2009.
*/
uint8_t * heapptr, * stackptr;   //GLOBALS!!
void check_mem() {
  stackptr = (uint8_t *)malloc(4);          // use stackptr temporarily
  heapptr = stackptr;                     // save value of heap pointer
  free(stackptr);      // free up the memory again (sets stackptr to 0)
  stackptr =  (uint8_t *)(SP);           // save value of stack pointer
}

void printHeapStack()
{
  int n;
  check_mem();
  Serial.print("Heap / Stack = ");
  n = (int) heapptr;
  Serial.print(n);
  Serial.print(", ");
  n = (int) stackptr;
  Serial.println(n);
}

void analogOutput() // output on pins 3 and 5 my partner's voltages
{
  int x;
  x = nodeValuesA0[partnerNode];
  analogWrite(3, x / 4); // analog inputs are 0-1023, outputs are 0-255
  x = nodeValuesA1[partnerNode];
  analogWrite(5, x / 4);
}
